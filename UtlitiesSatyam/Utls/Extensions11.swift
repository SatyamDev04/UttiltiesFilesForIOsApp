//
//  Extension.swift
//  DriverApp
//
//  Created by Devendra Agnihotri on 23/01/17.
//  Copyright Â© 2017 Devendra Agnihotri. All rights reserved.
//

import Foundation
import UIKit
import QuartzCore
import AVFoundation
import Combine

extension String {
    
    var convert_to_string:String? {
        var link  = self.replacingOccurrences(of: " ", with: "%20")
        return link.replacingOccurrences(of: "\"", with: "%22")
        
    }
  
}

/// Computed properties, based on the backing CALayer property, that are visible in Interface Builder.
//extension UIView {
//    
//    /// When positive, the background of the layer will be drawn with rounded corners. Also effects the mask generated by the `masksToBounds' property. Defaults to zero. Animatable.
//    @IBInspectable var cornerRadius: Double {
//        get {
//            return Double(self.layer.cornerRadius)
//        }
//        set {
//            self.layer.cornerRadius = CGFloat(newValue)
//        }
//    }
//    
//    /// The width of the layer's border, inset from the layer bounds. The border is composited above the layer's content and sublayers and includes the effects of the `cornerRadius' property. Defaults to zero. Animatable.
//    @IBInspectable var borderWidth: Double {
//        get {
//            return Double(self.layer.borderWidth)
//        }
//        set {
//            self.layer.borderWidth = CGFloat(newValue)
//        }
//    }
//    
//    /// The color of the layer's border. Defaults to opaque black. Colors created from tiled patterns are supported. Animatable.
//    @IBInspectable var borderColor: UIColor? {
//        get {
//            return UIColor(cgColor: self.layer.borderColor!)
//        }
//        set {
//            self.layer.borderColor = newValue?.cgColor
//        }
//    }
//    
//    /// The color of the shadow. Defaults to opaque black. Colors created from patterns are currently NOT supported. Animatable.
//    @IBInspectable var shadowColor: UIColor? {
//        get {
//            return UIColor(cgColor: self.layer.shadowColor!)
//        }
//        set {
//            self.layer.shadowColor = newValue?.cgColor
//        }
//    }
//    
//    /// The opacity of the shadow. Defaults to 0. Specifying a value outside the [0,1] range will give undefined results. Animatable.
//    @IBInspectable var shadowOpacity: Float {
//        get {
//            return self.layer.shadowOpacity
//        }
//        set {
//            self.layer.shadowOpacity = newValue
//        }
//    }
//    
//    /// The shadow offset. Defaults to (0, -3). Animatable.
//    @IBInspectable var shadowOffset: CGSize {
//        get {
//            return self.layer.shadowOffset
//        }
//        set {
//            self.layer.shadowOffset = newValue
//        }
//    }
//    
//    /// The blur radius used to create the shadow. Defaults to 3. Animatable.
//    @IBInspectable var shadowRadius: Double {
//        get {
//            return Double(self.layer.shadowRadius)
//        }
//        set {
//            self.layer.shadowRadius = CGFloat(newValue)
//        }
//    }
//    
//    
//    @IBInspectable var topLeftRadius: CGFloat {
//        get {
//            return self.layer.cornerRadius
//        }
//        set {
//            let maskPath1 = UIBezierPath(roundedRect: bounds, byRoundingCorners: [.topLeft], cornerRadii: CGSize(width: newValue, height: newValue))
//            let maskLayer1 = CAShapeLayer()
//            maskLayer1.frame = bounds
//            maskLayer1.path = maskPath1.cgPath
//            layer.mask = maskLayer1
//        }
//    }
//   
//    
//    
//}
extension WKWebView {

    /// load HTML String same font like the UIWebview
    ///
    //// - Parameters:
    ///   - content: HTML content which we need to load in the webview.
    ///   - baseURL: Content base url. It is optional.
    func loadHTMLStringWithMagic(content:String,baseURL:URL?){
        let headerString = "<header><meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no'></header>"
        loadHTMLString(headerString + content, baseURL: baseURL)
    }
}
extension UIImageView {
    
    @IBInspectable var ImageSet: Bool {
        get {
            return Bool(self.ImageSet)
        }
        set {
            let v = newValue
            if v {
//                self.pavan_tapToSeeFullImage()
            }
        }
    }
}
//#MARK: - Gradiont Color
import UIKit
import WebKit

@IBDesignable
class PaddedTextField: UITextField {

    @IBInspectable var leftPadding: CGFloat = 0 {
        didSet {
            setNeedsDisplay()
        }
    }

    @IBInspectable var rightPadding: CGFloat = 0 {
        didSet {
            setNeedsDisplay()
        }
    }

    override func textRect(forBounds bounds: CGRect) -> CGRect {
        let padding = UIEdgeInsets(top: 0, left: leftPadding, bottom: 0, right: rightPadding)
        return bounds.inset(by: padding)
    }

    override func editingRect(forBounds bounds: CGRect) -> CGRect {
        let padding = UIEdgeInsets(top: 0, left: leftPadding, bottom: 0, right: rightPadding)
        return bounds.inset(by: padding)
    }
}

extension UIColor {
    convenience init(hex: String) {
        var hexSanitized = hex.trimmingCharacters(in: .whitespacesAndNewlines)
        hexSanitized = hexSanitized.replacingOccurrences(of: "#", with: "")
        
        var rgb: UInt64 = 0
        
        Scanner(string: hexSanitized).scanHexInt64(&rgb)
        
        let red = CGFloat((rgb & 0xFF0000) >> 16) / 255.0
        let green = CGFloat((rgb & 0x00FF00) >> 8) / 255.0
        let blue = CGFloat(rgb & 0x0000FF) / 255.0
        let alpha = CGFloat(1.0)
        
        self.init(red: red, green: green, blue: blue, alpha: alpha)
    }
}
extension UIView {
    
    var borderWidth: Double {
            get {
                return Double(self.layer.borderWidth)
            }
            set {
                self.layer.borderWidth = CGFloat(newValue)
            }
        }
        func setGradientBackground(view: UIView, colorOne: UIColor, colorTwo: UIColor, colorThree: UIColor)  {
            let gradientlayer = CAGradientLayer()
            gradientlayer.frame = view.bounds
            gradientlayer.colors = [colorOne.cgColor, colorTwo.cgColor, colorThree.cgColor]
            //gradientlayer.cornerRadius = 15.0
            gradientlayer.locations = [0, 0.53, 1]
            gradientlayer.startPoint = CGPoint(x: 0.25, y: 0.5)
            gradientlayer.endPoint = CGPoint(x: 0.75, y: 0.5)
            gradientlayer.frame = CGRect(x: view.bounds.minX , y: view.bounds.minY, width: view.bounds.size.width , height: view.frame.size.height)
            view.layer.insertSublayer(gradientlayer, at: 0)
            
            
        }
    
    func shake(duration: CFTimeInterval) {
        
        let translation = CAKeyframeAnimation(keyPath: "transform.translation.x");
        translation.timingFunction = CAMediaTimingFunction(name: CAMediaTimingFunctionName.linear)
        translation.values = [-5, 5, -5, 5, -3, 3, -2, 2, 0]
        
        let rotation = CAKeyframeAnimation(keyPath: "transform.rotation.z")
        rotation.values = [-5, 5, -5, 5, -3, 3, -2, 2, 0].map {
            ( degrees: Double) -> Double in
            let radians: Double = (M_PI_2 * degrees) / 180.0
            return radians
        }
        
        let shakeGroup: CAAnimationGroup = CAAnimationGroup()
        shakeGroup.animations = [translation, rotation]
        shakeGroup.duration = duration
        self.layer.add(shakeGroup, forKey: "shakeIt")
    }
    
    
}

//Mark: extension for round two cornor

extension UIView {
    
    func roundCorners(_ corners:UIRectCorner, radius: CGFloat) {
        
        let path = UIBezierPath(roundedRect: self.bounds, byRoundingCorners: corners, cornerRadii: CGSize(width: radius, height: radius))
        let mask = CAShapeLayer()
        mask.path = path.cgPath
        self.layer.mask = mask
    }
    var borderColor: UIColor? {
            get {
                return UIColor(cgColor: self.layer.borderColor!)
            }
            set {
                self.layer.borderColor = newValue?.cgColor
            }
        }
}

extension UIButton {
    
    func roundCornersButton(_ corners:UIRectCorner, radius: CGFloat) {
        
        let path = UIBezierPath(roundedRect: self.bounds, byRoundingCorners: corners, cornerRadii: CGSize(width: radius, height: radius))
        let mask = CAShapeLayer()
        mask.path = path.cgPath
        self.layer.mask = mask
    }
    @IBInspectable var minimumfontsize: CGFloat {
        get {
            return CGFloat(self.titleLabel?.font.pointSize ?? 20)
        }
        set {
            self.titleLabel!.minimumScaleFactor = newValue
            self.titleLabel!.numberOfLines = 0
            self.titleLabel!.adjustsFontSizeToFitWidth = true
        }
    }
}
extension UIButton
{
    var myOwnTag: Int?
    {
        get{
            return 0
        }
        set{
            var propertyVal : Int? = nil
            if let value = newValue{
                propertyVal = value
            }
        }
    }
}


//#MARK: - Extension String

extension String
{
    func trim() -> String
    {
        return self.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)
    }
    var length1: Int {
        return self.count
    }
    
    var html2AttributedString: NSAttributedString? {
        guard let data = data(using: .utf8) else { return nil }
        do {
            return  nil
            //return try NSAttributedString(data: data, options: [.documen: NSHTMLTextDocumentType, NSCharacterEncodingDocumentAttribute: String.Encoding.utf8.rawValue], documentAttributes: nil)
        } catch let error as NSError {
            print(error.localizedDescription)
            return  nil
        }
    }
    var html2String: String {
        return html2AttributedString?.string ?? ""
    }
    
    
}

//#MARK: - Extension UIApplication

extension UIApplication {
    var statusBarUIView: UIView? {

      if #available(iOS 13.0, *) {
          let tag = 3848245
          let keyWindow = UIApplication.shared.connectedScenes
              .map({$0 as? UIWindowScene})
              .compactMap({$0})
              .first?.windows.first

          if let statusBar = keyWindow?.viewWithTag(tag) {
              return statusBar
          } else {
              let height = keyWindow?.windowScene?.statusBarManager?.statusBarFrame ?? .zero
              let statusBarView = UIView(frame: height)
              statusBarView.tag = tag
              statusBarView.layer.zPosition = 999999

              keyWindow?.addSubview(statusBarView)
              return statusBarView
          }
      } else {
          if responds(to: Selector(("statusBar"))) {
              return value(forKey: "statusBar") as? UIView
          }
      }
      return nil
    }
}


//#MARK: - Extension TextField Placeholder

extension UITextField{
    
    @IBInspectable var placeHolderColor: UIColor? {
        get {
            return self.placeHolderColor
        }
        set {
            self.attributedPlaceholder = NSAttributedString(string:self.placeholder != nil ? self.placeholder! : "", attributes:[NSAttributedString.Key.foregroundColor: newValue!])
        }
    }
    @IBInspectable var shadowOffsetP: CGSize {
        get {
            return self.layer.shadowOffset
        }
        set {
            self.layer.shadowOffset = newValue
        }
    }
    func lenth()-> Int{
        
        
        return self.text!.count
        
    }
    
    func useUnderline() {
        let border = CALayer()
        let borderWidth = CGFloat(1.0)
        border.borderColor = UIColor.lightGray.cgColor
        border.frame = CGRect(origin: CGPoint(x: 0,y :self.frame.size.height - borderWidth), size: CGSize(width: self.frame.size.width, height: self.frame.size.height))
        border.borderWidth = borderWidth
        self.layer.addSublayer(border)
        self.layer.masksToBounds = true
    }
    
//    @IBInspectable var placeHolderAddStar: UIColor? {
//        get {
//            return self.placeHolderAddStar
//        }
//        set {
//            let passwordAttriburedString = NSMutableAttributedString(string:self.placeholder != nil ? self.placeholder! : "", attributes:[NSAttributedString.Key.foregroundColor: newValue!])
//                
//            let asterix = NSAttributedString(string: "*", attributes: [.foregroundColor: UIColor.red])
//            passwordAttriburedString.append(asterix)
//
//            self.attributedPlaceholder = passwordAttriburedString
//            
//        }
//    }
    
}



//#MARK: - UIViewController

extension UIViewController {
    
    
    
    func hideKeyboardWhenTappedAround() {
        
        let tap: UITapGestureRecognizer = UITapGestureRecognizer(target: self, action: #selector(UIViewController.dismissKeyboard))
        view.addGestureRecognizer(tap)
    }
    
    @objc func dismissKeyboard() {
        view.endEditing(true)
    }
}

//#MARK: - Double
extension Double {
    var km: Double { return self * 1_000.0 }
    var m: Double { return self }
    var cm: Double { return self / 100.0 }
    var mm: Double { return self / 1_000.0 }
    var ft: Double { return self / 3.28084 }
}
//#MARK: - Image Extension

extension UIImage {
    
    
    func maskWithColor(_ color: UIColor) -> UIImage? {
        let maskImage = cgImage!
        
        let width = size.width
        let height = size.height
        let bounds = CGRect(x: 0, y: 0, width: width, height: height)
        
        let colorSpace = CGColorSpaceCreateDeviceRGB()
        let bitmapInfo = CGBitmapInfo(rawValue: CGImageAlphaInfo.premultipliedLast.rawValue)
        let context = CGContext(data: nil, width: Int(width), height: Int(height), bitsPerComponent: 8, bytesPerRow: 0, space: colorSpace, bitmapInfo: bitmapInfo.rawValue)!
        
        context.clip(to: bounds, mask: maskImage)
        context.setFillColor(color.cgColor)
        context.fill(bounds)
        
        if let cgImage = context.makeImage() {
            let coloredImage = UIImage(cgImage: cgImage)
            return coloredImage
        } else {
            return nil
        }
    }
    
    
    func resizeImage(image:UIImage, maxHeight:Float, maxWidth:Float) -> UIImage
    {
        var actualHeight:Float = Float(image.size.height)
        var actualWidth:Float = Float(image.size.width)
        
        var imgRatio:Float = actualWidth/actualHeight
        let maxRatio:Float = maxWidth/maxHeight
        
        if (actualHeight > maxHeight) || (actualWidth > maxWidth)
        {
            if(imgRatio < maxRatio)
            {
                imgRatio = maxHeight / actualHeight;
                actualWidth = imgRatio * actualWidth;
                actualHeight = maxHeight;
            }
            else if(imgRatio > maxRatio)
            {
                imgRatio = maxWidth / actualWidth;
                actualHeight = imgRatio * actualHeight;
                actualWidth = maxWidth;
            }
            else
            {
                actualHeight = maxHeight;
                actualWidth = maxWidth;
            }
        }
        
        let rect:CGRect = CGRect(x: 0.0, y: 0.0, width: CGFloat(actualWidth), height: CGFloat(actualHeight))
        UIGraphicsBeginImageContext(rect.size)
        image.draw(in: rect)
        
        let img:UIImage = UIGraphicsGetImageFromCurrentImageContext()!
        let imageData:NSData = img.jpegData(compressionQuality: 1.0)! as NSData
        
//    let imageData:NSData = UIImageJPEGRepresentation(img, 1.0)! as NSData
        UIGraphicsEndImageContext()
        
        return UIImage(data: imageData as Data)!
        
    }
    func resized(withPercentage percentage: CGFloat) -> UIImage? {
        let canvasSize = CGSize(width: size.width * percentage, height: size.height * percentage)
        UIGraphicsBeginImageContextWithOptions(canvasSize, false, scale)
        defer { UIGraphicsEndImageContext() }
        draw(in: CGRect(origin: .zero, size: canvasSize))
        return UIGraphicsGetImageFromCurrentImageContext()
    }

    func resizeWithPercent(percentage: CGFloat) -> UIImage? {
        let imageView = UIImageView(frame: CGRect(origin: .zero, size: CGSize(width: size.width * percentage, height: size.height * percentage)))
        imageView.contentMode = .scaleAspectFit
        imageView.image = self
        UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, false, scale)
        guard let context = UIGraphicsGetCurrentContext() else { return nil }
        imageView.layer.render(in: context)
        guard let result = UIGraphicsGetImageFromCurrentImageContext() else { return nil }
        UIGraphicsEndImageContext()
        return result
    }
  
    
    func resizeByByte(maxMB: Double, completion: @escaping (Data) -> Void) {
        
        var compressQuality: CGFloat = 1
        var imageData = Data()
        let max = maxMB * 1000000.0
        var imageByte = Double(self.jpegData(compressionQuality: 1.0)?.count ?? 0)
        imageData = self.jpegData(compressionQuality: compressQuality)!
                
        while imageByte > max {
            imageData = self.jpegData(compressionQuality: compressQuality)!
            imageByte = Double(imageData.count)
//            imageByte = Double(self.jpegData(compressionQuality: compressQuality)?.count ?? 0)
            compressQuality -= 0.1
        }
        
        if max > imageByte {
            completion(imageData)
        } else {
            completion(self.jpegData(compressionQuality: 1.0)!)
        }
    }
    func resize(withPercentage percentage: CGFloat) -> UIImage? {
        var newRect = CGRect(origin: .zero, size: CGSize(width: size.width*percentage, height: size.height*percentage))
        UIGraphicsBeginImageContextWithOptions(newRect.size, true, 1)
        self.draw(in: newRect)
        defer {UIGraphicsEndImageContext()}
        return UIGraphicsGetImageFromCurrentImageContext()
    }
}

//#MARK:- random color

extension CGFloat {
    static func random() -> CGFloat {
        return CGFloat(arc4random()) / CGFloat(UInt32.max)
    }
}

extension UIColor {
    static var random: UIColor {
        return UIColor(red: .random(), green: .random(), blue: .random(), alpha: 1.0)
    }
}


////#MARK:- ********* Extenstion Device name********
//
//public extension UIDevice {
//    
//    static let modelName: String = {
//        var systemInfo = utsname()
//        uname(&systemInfo)
//        let machineMirror = Mirror(reflecting: systemInfo.machine)
//        let identifier = machineMirror.children.reduce("") { identifier, element in
//            guard let value = element.value as? Int8, value != 0 else { return identifier }
//            return identifier + String(UnicodeScalar(UInt8(value)))
//        }
//        
//        func mapToDevice(identifier: String) -> String { // swiftlint:disable:this cyclomatic_complexity
//            #if os(iOS)
//            switch identifier {
//            case "iPod5,1":                                 return "iPod Touch 5"
//            case "iPod7,1":                                 return "iPod Touch 6"
//            case "iPhone3,1", "iPhone3,2", "iPhone3,3":     return "iPhone 4"
//            case "iPhone4,1":                               return "iPhone 4s"
//            case "iPhone5,1", "iPhone5,2":                  return "iPhone 5"
//            case "iPhone5,3", "iPhone5,4":                  return "iPhone 5c"
//            case "iPhone6,1", "iPhone6,2":                  return "iPhone 5s"
//            case "iPhone7,2":                               return "iPhone 6"
//            case "iPhone7,1":                               return "iPhone 6 Plus"
//            case "iPhone8,1":                               return "iPhone 6s"
//            case "iPhone8,2":                               return "iPhone 6s Plus"
//            case "iPhone9,1", "iPhone9,3":                  return "iPhone 7"
//            case "iPhone9,2", "iPhone9,4":                  return "iPhone 7 Plus"
//            case "iPhone8,4":                               return "iPhone SE"
//            case "iPhone10,1", "iPhone10,4":                return "iPhone 8"
//            case "iPhone10,2", "iPhone10,5":                return "iPhone 8 Plus"
//            case "iPhone10,3", "iPhone10,6":                return "iPhone X"
//            case "iPhone11,2":                              return "iPhone XS"
//            case "iPhone11,4", "iPhone11,6":                return "iPhone XS Max"
//            case "iPhone11,8":                              return "iPhone XR"
//            case "iPad2,1", "iPad2,2", "iPad2,3", "iPad2,4":return "iPad 2"
//            case "iPad3,1", "iPad3,2", "iPad3,3":           return "iPad 3"
//            case "iPad3,4", "iPad3,5", "iPad3,6":           return "iPad 4"
//            case "iPad4,1", "iPad4,2", "iPad4,3":           return "iPad Air"
//            case "iPad5,3", "iPad5,4":                      return "iPad Air 2"
//            case "iPad6,11", "iPad6,12":                    return "iPad 5"
//            case "iPad7,5", "iPad7,6":                      return "iPad 6"
//            case "iPad2,5", "iPad2,6", "iPad2,7":           return "iPad Mini"
//            case "iPad4,4", "iPad4,5", "iPad4,6":           return "iPad Mini 2"
//            case "iPad4,7", "iPad4,8", "iPad4,9":           return "iPad Mini 3"
//            case "iPad5,1", "iPad5,2":                      return "iPad Mini 4"
//            case "iPad6,3", "iPad6,4":                      return "iPad Pro (9.7-inch)"
//            case "iPad6,7", "iPad6,8":                      return "iPad Pro (12.9-inch)"
//            case "iPad7,1", "iPad7,2":                      return "iPad Pro (12.9-inch) (2nd generation)"
//            case "iPad7,3", "iPad7,4":                      return "iPad Pro (10.5-inch)"
//            case "iPad8,1", "iPad8,2", "iPad8,3", "iPad8,4":return "iPad Pro (11-inch)"
//            case "iPad8,5", "iPad8,6", "iPad8,7", "iPad8,8":return "iPad Pro (12.9-inch) (3rd generation)"
//            case "AppleTV5,3":                              return "Apple TV"
//            case "AppleTV6,2":                              return "Apple TV 4K"
//            case "AudioAccessory1,1":                       return "HomePod"
//                //            case "i386", "x86_64":                          return "Simulator \(mapToDevice(identifier: ProcessInfo().environment["SIMULATOR_MODEL_IDENTIFIER"] ?? "iOS"))"
//                
//                
//            case "i386", "x86_64":                          return "\(mapToDevice(identifier: ProcessInfo().environment["SIMULATOR_MODEL_IDENTIFIER"] ?? "iOS"))"
//                
//            default:                                        return identifier
//            }
//            #elseif os(tvOS)
//            switch identifier {
//            case "AppleTV5,3": return "Apple TV 4"
//            case "AppleTV6,2": return "Apple TV 4K"
//            case "i386", "x86_64": return "Simulator \(mapToDevice(identifier: ProcessInfo().environment["SIMULATOR_MODEL_IDENTIFIER"] ?? "tvOS"))"
//            default: return identifier
//            }
//            #endif
//        }
//        
//        return mapToDevice(identifier: identifier)
//    }()
//    
//}



//#MARK:- ********* Extenstion Array********
extension Array {
    
    func randomItem() -> Element {
        let index = Int(arc4random_uniform(UInt32(self.count)))
        return self[index]
    }
    
}
//#MARK:- ********* Extenstion CG POINT********
//extension CGPoint {
//
//    func distance(from point: CGPoint) -> CGFloat {
//        return hypot(point.x - x, point.y - y)
//    }
//
//}
extension String {
    func isEqualToString(find: String) -> Bool {
        return String(format: self) == find
    }
}


//#MARK:- ********* Extenstion UIProgressView ********



extension UIProgressView {
    @IBInspectable var sizeOfPropgress: CGSize {
        get {
            return CGSize(width: 1, height: 1)
        }
        set {
            self.transform = self.transform.scaledBy(x: newValue.width, y: newValue.height)
            self.layer.cornerRadius = 2*newValue.height
            self.clipsToBounds = true
            self.layer.sublayers![1].cornerRadius = newValue.height
            self.subviews[1].clipsToBounds = true
        }
    }
}

extension UITableView {
    
    func setEmptyMessage(_ message: String) {
        let messageLabel = UILabel(frame: CGRect(x: 0, y: 0, width: self.bounds.size.width, height: self.bounds.size.height))
        messageLabel.text = message
        messageLabel.textColor = .orange
        messageLabel.numberOfLines = 0
        messageLabel.textAlignment = .center
        messageLabel.font = UIFont.boldSystemFont(ofSize: 25)
        messageLabel.sizeToFit()

        self.backgroundView = messageLabel
        self.separatorStyle = .none
    }
    
    func setEmptyImag(_ message: UIImage) {
//          let messageLabel = UILabel(frame: CGRect(x: 0, y: 0, width: self.bounds.size.width, height: self.bounds.size.height))
        let messageLabel = UIImageView(frame: CGRect(x: self.center.x, y: center.y, width: self.bounds.size.width, height: self.bounds.size.height))
//          messageLabel.text = message
//          messageLabel.textColor = .black
//          messageLabel.numberOfLines = 0
//          messageLabel.textAlignment = .center
//          messageLabel.font = UIFont(name: AppFonts.Bebas_Neue_Pro_Book.rawValue, size: 15)
          messageLabel.image = message
//          messageLabel.sizeToFit()
          messageLabel.contentMode = .scaleAspectFit

          self.backgroundView = messageLabel
          self.separatorStyle = .none
      }

    func restore() {
        self.backgroundView = nil
        self.separatorStyle = .none
    }

}

extension UICollectionView {

    func setEmptyMessage(_ message: String,_ img:UIImage) {

        let image = UIImageView()
        image.contentMode = .center//.scaleAspectFit
        image.image = img


        let messageLabel = UILabel()
        messageLabel.text = message
        messageLabel.font = UIFont.boldSystemFont(ofSize: 25)
        messageLabel.textColor = .purple
        messageLabel.numberOfLines = 0
        messageLabel.textAlignment = .center
        messageLabel.sizeToFit()

        let mainView = UIView()
        mainView.addSubview(image)
        mainView.addSubview(messageLabel)

        //Auto Layout
        image.translatesAutoresizingMaskIntoConstraints = false
        image.centerXAnchor.constraint(equalTo: mainView.centerXAnchor).isActive = true
        image.centerYAnchor.constraint(equalTo: mainView.centerYAnchor , constant: -40).isActive = true

        messageLabel.translatesAutoresizingMaskIntoConstraints = false
        messageLabel.topAnchor.constraint(equalTo: image.bottomAnchor, constant: 20).isActive = true
        messageLabel.leadingAnchor.constraint(equalTo: mainView.leadingAnchor, constant: 10).isActive = true
        messageLabel.trailingAnchor.constraint(equalTo: mainView.trailingAnchor, constant: 10).isActive = true

        self.backgroundView = mainView
    }

    func restoreBackgroundView() {
        self.backgroundView = nil
    }
}
//

class CurvedView: UIView {
     func drawRect(rect: CGRect) {

        let y:CGFloat = 20
        let curveTo:CGFloat = 0

        let myBezier = UIBezierPath()
        myBezier.move(to: CGPoint(x: 0, y: y))
        myBezier.addQuadCurve(to: CGPoint(x: rect.width, y: y), controlPoint: CGPoint(x: rect.width / 2, y: curveTo))
        myBezier.addLine(to: CGPoint(x: rect.width, y: rect.height))
        myBezier.addLine(to: CGPoint(x: 0, y: rect.height))
        myBezier.close()
        let context = UIGraphicsGetCurrentContext()
        context!.setLineWidth(4.0)
        UIColor.white.setFill()
        myBezier.fill()
    }
}

extension UIView {

    func addTopRoundedCornerToView(targetView:UIView?, desiredCurve:CGFloat?)
    {
        let offset:CGFloat =  targetView!.frame.width/desiredCurve!
        let bounds: CGRect = targetView!.bounds

        let rectBounds: CGRect = CGRect(x: bounds.origin.x, y: bounds.origin.y+bounds.size.height / 2, width: bounds.size.width, height: bounds.size.height)

        let rectPath: UIBezierPath = UIBezierPath(rect: rectBounds)
        let ovalBounds: CGRect = CGRect(x: bounds.origin.x - offset / 2, y: bounds.origin.y, width: bounds.size.width + offset, height: bounds.size.height)
        print(ovalBounds)
        let ovalPath: UIBezierPath = UIBezierPath(ovalIn: ovalBounds)
        rectPath.append(ovalPath)

        // Create the shape layer and set its path
        let maskLayer: CAShapeLayer = CAShapeLayer()
        maskLayer.frame = bounds
        maskLayer.path = rectPath.cgPath

        // Set the newly created shape layer as the mask for the view's layer
        targetView!.layer.mask = maskLayer
    }
}


extension UIViewController{
    func isImage(data: Data) -> Bool {
        let imageMagicNumbers: Set<Data> = [
            Data([0xFF, 0xD8, 0xFF]),  // JPEG
            Data([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]),  // PNG
            Data([0x47, 0x49, 0x46, 0x38, 0x37, 0x61]),  // GIF
            Data([0x47, 0x49, 0x46, 0x38, 0x39, 0x61]),  // GIF
            Data([0x42, 0x4D]),  // BMP
            Data([0x49, 0x49, 0x2A, 0x00]),  // TIFF
            Data([0x4D, 0x4D, 0x00, 0x2A]),  // TIFF
            Data([0x00, 0x00, 0x01, 0x00]),  // ICO
            Data([0x00, 0x00, 0x02, 0x00]),  // ICO
            Data([0x42, 0x50, 0x47, 0xFB]),  // WebP
            // Add more magic numbers for other image formats if needed
        ]
        
        return imageMagicNumbers.contains(data.prefix(imageMagicNumbers.first!.count))
    }
    
    func isPDF(data: Data) -> Bool {
        let pdfMagicNumber: Data = Data([0x25, 0x50, 0x44, 0x46])  // PDF
        
        return data.prefix(pdfMagicNumber.count) == pdfMagicNumber
    }
    
    func isMicrosoftWord(data: Data) -> Bool {
        let docMagicNumbers: Set<Data> = [
            Data([0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1]),  // DOC
            Data([0x50, 0x4B, 0x03, 0x04]),  // DOCX
        ]
        return docMagicNumbers.contains(data.prefix(docMagicNumbers.first!.count))
    }
}

extension UITabBarController {
    /// Extends the size of the `UITabBarController` view frame, pushing the tab bar controller off screen.
    /// - Parameters:
    ///   - hidden: Hide or Show the `UITabBar`
    ///   - animated: Animate the change
    func setTabBarHidden(_ hidden: Bool, animated: Bool) {
        guard let vc = selectedViewController else { return }
        guard tabBarHidden != hidden else { return }
        
        let frame = self.tabBar.frame
        let height = frame.size.height
        let offsetY = hidden ? height : -height
        
        UIViewPropertyAnimator(duration: animated ? 0.3 : 0, curve: .easeOut) {
            self.tabBar.frame = self.tabBar.frame.offsetBy(dx: 0, dy: offsetY)
            self.selectedViewController?.view.frame = CGRect(
                x: 0,
                y: 0,
                width: vc.view.frame.width,
                height: vc.view.frame.height + offsetY
            )
            
            self.view.setNeedsDisplay()
            self.view.layoutIfNeeded()
        }
        .startAnimation()
    }
    private var tabBarHidden: Bool {
        tabBar.frame.origin.y >= UIScreen.main.bounds.height
    }
  }

 

 
extension UILabel {
    
    static func spaceLabel() -> UILabel {
        let spacingLabel = UILabel()
        spacingLabel.frame = CGRect(x: 0, y: 0, width: 150, height: 50)
        spacingLabel.textColor = .white
        spacingLabel.textAlignment = .center
        spacingLabel.font = UIFont.boldSystemFont(ofSize: 18)
        spacingLabel.text = "LIKE ME"
        spacingLabel.backgroundColor = .red
        return spacingLabel
    }
    
    // adding space between each characters
    func addCharacterSpacing(kernValue: Double = 3) {
        if let labelText = text, labelText.isEmpty == false {
            let attributedString = NSMutableAttributedString(string: labelText)
            attributedString.addAttribute(.kern,
                                          value: kernValue,
                                          range: NSRange(location: 0, length: attributedString.length - 1))
            attributedText = attributedString
        }
    }
}


class GlobalDatePicker: UIView {

    private let datePicker: UIDatePicker

    // Callback closure to notify when the date is selected
    var dateSelected: ((Date) -> Void)?

    // Initialization
    override init(frame: CGRect) {
        datePicker = UIDatePicker()
        super.init(frame: frame)
        commonInit()
    }

    required init?(coder aDecoder: NSCoder) {
        datePicker = UIDatePicker()
        super.init(coder: aDecoder)
        commonInit()
    }

    private func commonInit() {
        // Configure date picker settings
        datePicker.datePickerMode = .date
        datePicker.addTarget(self, action: #selector(datePickerValueChanged), for: .valueChanged)

        // Add date picker to the view
        addSubview(datePicker)

        // Set constraints
        datePicker.translatesAutoresizingMaskIntoConstraints = false
        NSLayoutConstraint.activate([
            datePicker.topAnchor.constraint(equalTo: topAnchor),
            datePicker.leadingAnchor.constraint(equalTo: leadingAnchor),
            datePicker.trailingAnchor.constraint(equalTo: trailingAnchor),
            datePicker.bottomAnchor.constraint(equalTo: bottomAnchor)
        ])
    }

    // Action for date picker value change
    @objc private func datePickerValueChanged() {
        dateSelected?(datePicker.date)
    }

    // Public method to show the date picker
    func show() {
        // Implement your logic to present the date picker wherever needed
        // For example, you can add it to a specific view or window
    }

    // Public method to hide the date picker
    func hide() {
        // Implement your logic to hide the date picker
    }
}


extension String{
    
        func isVideoURL() -> Bool {
                guard let url = URL(string: self) else {
                    return false
                }

                let videoExtensions = ["mp4", "mov", "avi", "mkv", "flv"] // Add more video extensions as needed
            let fileExtension = url.pathExtension.lowercased()
                if  videoExtensions.contains(fileExtension) {
                    return true
                } else {
                    return false
                }
            }
}
extension UIViewController{
    func validateEmail(YourEMailAddress: String) -> Bool {
        let REGEX: String
        REGEX = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,3}"
        return NSPredicate(format: "SELF MATCHES %@", REGEX).evaluate(with: YourEMailAddress)
    }
     
    func isContainsAllZeros(testStr: String) -> Bool {
        
        
        let mobileNoRegEx = "^\\d{3}-\\d{3}-\\d{4}$"
        
        let mobileNoTest = NSPredicate(format: "SELF MATCHES %@", mobileNoRegEx)
        
        return mobileNoTest.evaluate(with: testStr)
        
    }
}

//extension UITextView {
//
//    private class PlaceholderLabel: UILabel { }
//
//    private var placeholderLabel: PlaceholderLabel {
//        if let label = subviews.compactMap( { $0 as? PlaceholderLabel }).first {
//
//            return label
//        } else {
//            let label = PlaceholderLabel(frame: .zero)
//            label.font = font
//            addSubview(label)
//            return label
//        }
//
//    }
//
////    @IBInspectable
////    var placeholder: String {
////        get {
////            return subviews.compactMap( { $0 as? PlaceholderLabel }).first?.text ?? ""
////        }
////        set {
////            let placeholderLabel = self.placeholderLabel
////            placeholderLabel.text = newValue
////            placeholderLabel.numberOfLines = 0
////            let width = frame.width - textContainer.lineFragmentPadding * 2
////            let size = placeholderLabel.sizeThatFits(CGSize(width: width, height: .greatestFiniteMagnitude))
////            placeholderLabel.frame.size.height = size.height
////            placeholderLabel.frame.size.width = width
////            placeholderLabel.frame.origin = CGPoint(x: textContainer.lineFragmentPadding, y: textContainerInset.top)
////
////            textStorage.delegate = self
////        }
////    }
//
//}

//extension UITextView: NSTextStorageDelegate {
//
//    public func textStorage(_ textStorage: NSTextStorage, didProcessEditing editedMask: NSTextStorage.EditActions, range editedRange: NSRange, changeInLength delta: Int) {
//        if editedMask.contains(.editedCharacters) {
//            placeholderLabel.isHidden = !text.isEmpty
//        }
//    }
//
//}

//extension UIViewController{
//    func checkCamera() {
//        let authStatus = AVCaptureDevice.authorizationStatus(for: AVMediaType.video)
//        switch authStatus {
//        case .authorized: break//callCamera() // Do your stuff here i.e. callCameraMethod()
//        case .denied: alertPromptToAllowCameraAccessViaSetting()
//        case .notDetermined: alertToEncourageCameraAccessInitially()
//        default: alertToEncourageCameraAccessInitially()
//        }
//    }
//
//    func alertToEncourageCameraAccessInitially() {
//        let alert = UIAlertController(
//            title: "IMPORTANT",
//            message: "Camera access required for capturing photos!",
//            preferredStyle: UIAlertController.Style.alert
//        )
//        alert.addAction(UIAlertAction(title: "Cancel", style: .default, handler: nil))
//        alert.addAction(UIAlertAction(title: "Allow Camera", style: .cancel, handler: { (alert) -> Void in
//            UIApplication.shared.openURL(URL(string: UIApplication.openSettingsURLString)!)
//        }))
//        present(alert, animated: true, completion: nil)
//    }
//
//    func alertPromptToAllowCameraAccessViaSetting() {
//
//        let alert = UIAlertController(
//            title: "IMPORTANT",
//            message: "Camera access required for capturing photos!",
//            preferredStyle: UIAlertController.Style.alert
//        )
//        alert.addAction(UIAlertAction(title: "Dismiss", style: .cancel) { alert in
//            if AVCaptureDevice.devices(for: AVMediaType.video).count > 0 {
//                AVCaptureDevice.requestAccess(for: AVMediaType.video) { granted in
//                    DispatchQueue.main.async() {
//                        self.checkCamera() } }
//            }
//            }
//        )
//        present(alert, animated: true, completion: nil)
//    }
//}


extension UIViewController {
    func setTabBar(hidden: Bool, animated: Bool) {
        guard let tabBar = self.tabBarController?.tabBar else { return }
        
        let tabBarHeight = tabBar.frame.size.height
        let viewFrame = self.view.frame
        
        if hidden {
            if animated {
                UIView.animate(withDuration: 0.3, animations: {
                    tabBar.frame.origin.y = self.view.frame.size.height
                    self.view.frame = CGRect(
                        x: viewFrame.origin.x,
                        y: viewFrame.origin.y,
                        width: viewFrame.size.width,
                        height: viewFrame.size.height + tabBarHeight
                    )
                    self.view.layoutIfNeeded()
                })
            } else {
                tabBar.frame.origin.y = self.view.frame.size.height
                self.view.frame = CGRect(
                    x: viewFrame.origin.x,
                    y: viewFrame.origin.y,
                    width: viewFrame.size.width,
                    height: viewFrame.size.height + tabBarHeight
                )
                self.view.layoutIfNeeded()
            }
        } else {
            if animated {
                UIView.animate(withDuration: 0.3, animations: {
                    tabBar.frame.origin.y = self.view.frame.size.height - tabBarHeight
                    self.view.frame = CGRect(
                        x: viewFrame.origin.x,
                        y: viewFrame.origin.y,
                        width: viewFrame.size.width,
                        height: viewFrame.size.height - tabBarHeight
                    )
                    self.view.layoutIfNeeded()
                })
            } else {
                tabBar.frame.origin.y = self.view.frame.size.height - tabBarHeight
                self.view.frame = CGRect(
                    x: viewFrame.origin.x,
                    y: viewFrame.origin.y,
                    width: viewFrame.size.width,
                    height: viewFrame.size.height - tabBarHeight
                )
                self.view.layoutIfNeeded()
            }
        }
    }
}
extension UITextField {
    var textPublisher: AnyPublisher<String?, Never> {
        NotificationCenter.default.publisher(for: UITextField.textDidChangeNotification, object: self)
            .map { ($0.object as? UITextField)?.text }
            .eraseToAnyPublisher()
    }
}

struct AnyDataType: Codable {
    var value: String = ""

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()

       
        if let stringValue = try? container.decode(String.self) {
            if let doubleValue = Double(stringValue) {
                if stringValue.contains(".") {
                    value = String(format: "%.2f", doubleValue)
                } else {
                    value = stringValue
                }
            } else {
                value = stringValue
            }
            return
            
        }
        if let intValue = try? container.decode(Int.self) {
            value = String(intValue)
            return
        }
        
        if let DoubleValue = try? container.decode(Double.self) {
            let roundedValue = String(format: "%.2f", DoubleValue)
            value = String(roundedValue)
            return
        }
      
        throw DecodingError.typeMismatch(
            AnyDataType.self,
            DecodingError.Context(
                codingPath: decoder.codingPath,
                debugDescription: "Expected String or Int for FlexibleString"
            )
        )
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(value)
    }
}
