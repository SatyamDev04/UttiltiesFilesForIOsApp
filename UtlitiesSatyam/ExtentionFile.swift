//
//  ExtentionFile.swift
//  MyAirSpa_YesITLabs
//
//  Created by YATIN  KALRA on 13/12/23.
//

import Foundation
import UIKit
import AVKit
import SDWebImage

extension UIView {
    
    /// When positive, the background of the layer will be drawn with rounded corners. Also effects the mask generated by the `masksToBounds' property. Defaults to zero. Animatable.
    @IBInspectable var cornerRadius: Double {
        get {
            return Double(self.layer.cornerRadius)
        }
        set {
            self.layer.cornerRadius = CGFloat(newValue)
        }
    }
    
    /// The width of the layer's border, inset from the layer bounds. The border is composited above the layer's content and sublayers and includes the effects of the `cornerRadius' property. Defaults to zero. Animatable.
    
    
    /// The color of the layer's border. Defaults to opaque black. Colors created from tiled patterns are supported. Animatable.

    
    /// The color of the shadow. Defaults to opaque black. Colors created from patterns are currently NOT supported. Animatable.
    @IBInspectable var shadowColor: UIColor? {
        get {
            return UIColor(cgColor: self.layer.shadowColor!)
        }
        set {
            self.layer.shadowColor = newValue?.cgColor
        }
    }
    
    /// The opacity of the shadow. Defaults to 0. Specifying a value outside the [0,1] range will give undefined results. Animatable.
    @IBInspectable var shadowOpacity: Float {
        get {
            return self.layer.shadowOpacity
        }
        set {
            self.layer.shadowOpacity = newValue
        }
    }
    
    /// The shadow offset. Defaults to (0, -3). Animatable.
    @IBInspectable var shadowOffset: CGSize {
        get {
            return self.layer.shadowOffset
        }
        set {
            self.layer.shadowOffset = newValue
        }
    }
    
    /// The blur radius used to create the shadow. Defaults to 3. Animatable.
    @IBInspectable var shadowRadius: Double {
        get {
            return Double(self.layer.shadowRadius)
        }
        set {
            self.layer.shadowRadius = CGFloat(newValue)
        }
    }
    
    
    @IBInspectable var topLeftRadius: CGFloat {
        get {
            return self.layer.cornerRadius
        }
        set {
            let maskPath1 = UIBezierPath(roundedRect: bounds, byRoundingCorners: [.topLeft], cornerRadii: CGSize(width: newValue, height: newValue))
            let maskLayer1 = CAShapeLayer()
            maskLayer1.frame = bounds
            maskLayer1.path = maskPath1.cgPath
            layer.mask = maskLayer1
        }
    }
    
}
extension String {
    
    func fileName() -> String {
        return URL(fileURLWithPath: self).deletingPathExtension().lastPathComponent
    }
    
    func fileExtension() -> String {
        return URL(fileURLWithPath: self).pathExtension ?? ""
    }
    func fileNameWithExtension() -> String {
        let pn = self.fileName()
        let En = self.fileExtension()
        return  "\(pn).\(En)"
        //        let nameStr = URL(fileURLWithPath: self).deletingPathExtension().lastPathComponent
        //        let extensionStr = URL(fileURLWithPath: self).pathExtension
        //        return  "\(nameStr).\(extensionStr)"
    }
    
}
extension UIView {
    func addRoundedBorder(color: UIColor, thickness: CGFloat, cornerRadius: CGFloat) {
          layer.borderColor = color.cgColor
          layer.borderWidth = thickness
          layer.cornerRadius = cornerRadius
          layer.masksToBounds = true
      }
}
extension Publisher {
    /// Simplifies error handling for Combine pipelines
    func handleError(_ handler: @escaping (Failure) -> Void) -> Publishers.HandleEvents<Self> {
        return self.handleEvents(receiveCompletion: { completion in
            if case .failure(let error) = completion {
                handler(error)
            }
        })
    }
}
extension UIView {
    func addDashedBorder() {
        let color = UIColor.white.cgColor

      let shapeLayer:CAShapeLayer = CAShapeLayer()
      let frameSize = self.frame.size
      let shapeRect = CGRect(x: 0, y: 0, width: frameSize.width, height: frameSize.height)

      shapeLayer.bounds = shapeRect
      shapeLayer.position = CGPoint(x: frameSize.width/2, y: frameSize.height/2)
      shapeLayer.fillColor = UIColor.clear.cgColor
      shapeLayer.strokeColor = color
      shapeLayer.lineWidth = 2
      shapeLayer.lineJoin = CAShapeLayerLineJoin.round
      shapeLayer.lineDashPattern = [3,6]
      shapeLayer.path = UIBezierPath(roundedRect: shapeRect, cornerRadius: 5).cgPath

      self.layer.addSublayer(shapeLayer)
      }
}
class PasswordTextField: UITextField {
    
    private let eyeButton = UIButton(type: .custom)
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        setupTextField()
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        setupTextField()
    }
    
    private func setupTextField() {
        // Set secure entry and default placeholder
        self.isSecureTextEntry = true
        self.placeholder = self.placeholder ?? "Enter Password"
        
        // Configure the eye button
        let eyeImage = UIImage(systemName: "eye.slash.fill") // Use SF Symbols
        eyeButton.setImage(eyeImage, for: .normal)
        eyeButton.tintColor = .gray
        eyeButton.frame = CGRect(x: 0, y: 0, width: 30, height: 30)
        eyeButton.addTarget(self, action: #selector(togglePasswordVisibility), for: .touchUpInside)
        
        // Add the button as the right view
        self.rightView = eyeButton
        self.rightViewMode = .always
    }
    
    @objc private func togglePasswordVisibility() {
        self.isSecureTextEntry.toggle()
      
        // Update the eye icon based on visibility state
        let eyeImageName = self.isSecureTextEntry ? "eye.slash.fill" : "eye.fill"
        eyeButton.setImage(UIImage(systemName: eyeImageName), for: .normal)
    }
}
extension UIImageView {
    
    func loadImage(from url: String?, placeholder: UIImage? = nil, indicator: SDWebImageActivityIndicator = .grayLarge) {
        // Set up the loading indicator
        self.sd_imageIndicator = indicator
        let url = AppURL.imageURL + (url ?? "")
        
        // Load the image from the URL
        self.sd_setImage(with: URL(string: url), placeholderImage: placeholder, options: .highPriority, completed: { (image, error, cacheType, url) in
            if let error = error {
                print("Error loading image: \(error.localizedDescription)")
            } else {
                print("Image loaded successfully from URL: \(url?.absoluteString ?? "unknown")")
            }
        })
    }
    
    func loadImage1(from url: String?, placeholder: UIImage? = nil, indicator: SDWebImageActivityIndicator = .grayLarge) {
        // Set up the loading indicator
        self.sd_imageIndicator = indicator
        let url = AppURL.imageURLAbousUs + (url ?? "")
        
        // Load the image from the URL
        self.sd_setImage(with: URL(string: url), placeholderImage: placeholder, options: .highPriority, completed: { (image, error, cacheType, url) in
            if let error = error {
                print("Error loading image: \(error.localizedDescription)")
            } else {
                print("Image loaded successfully from URL: \(url?.absoluteString ?? "unknown")")
            }
        })
    }
}
extension NSObject {
    func formatPhoneNumberToNormal(_ phoneNumber: String) -> String {
        let strippedPhoneNumber = phoneNumber.replacingOccurrences(of: "[^0-9]", with: "", options: .regularExpression)
        
        // Remove country code if present
        if strippedPhoneNumber.count >= 11 {
            let startIndex = strippedPhoneNumber.index(strippedPhoneNumber.startIndex, offsetBy: 1)
            let endIndex = strippedPhoneNumber.endIndex
            let finalNumber = String(strippedPhoneNumber[startIndex..<endIndex])
            return finalNumber
        } else {
            return strippedPhoneNumber
        }
    }
    func printModelAsJSON<T: Codable>(_ model: T,para:[String:Any]?) {
#if DEBUG
        print("============================Parameter==================")
        print(para ?? [:])
        print("============================Response==================")
        do {
            let encoder = JSONEncoder()
            encoder.outputFormatting = .prettyPrinted
            let jsonData = try encoder.encode(model)

            // Print the JSON as a string
            if let jsonString = String(data: jsonData, encoding: .utf8) {
                print("\(jsonString)")
            }
        } catch {
            print("Error encoding model to JSON: \(error)")
        }
#endif
    }
    
    func convertModelToJsonString<T: Codable>(_ model: T?) -> String?{
        guard let model = model else {
            print("Exit from gaurd")
            return ""
        }
        let encoder = JSONEncoder()
        encoder.outputFormatting = .prettyPrinted

        do {
            let jsonData = try encoder.encode(model)
            if let jsonString = String(data: jsonData, encoding: .utf8) {
              print(jsonString)
              return jsonString
                
            }
        } catch {
            print("Error encoding intervals to JSON: \(error)")
            return ""
        }
        return ""
    }


}

extension Encodable {
    func toDictionary() -> [String: Any]? {
        guard let data = try? JSONEncoder().encode(self) else { return nil }
        return (try? JSONSerialization.jsonObject(with: data, options: .allowFragments))
            as? [String: Any]
    }
}
extension URL {
    func getThumbnailImageFromVideoUrl1(completion: @escaping ((_ image: UIImage?)->Void)) {
        DispatchQueue.global().async { //1
            let asset = AVAsset(url: self) //2
            let avAssetImageGenerator = AVAssetImageGenerator(asset: asset) //3
            avAssetImageGenerator.appliesPreferredTrackTransform = true //4
            let thumnailTime = CMTimeMake(value: 2, timescale: 1) //5
            do {
                let cgThumbImage = try avAssetImageGenerator.copyCGImage(at: thumnailTime, actualTime: nil) //6
                let thumbNailImage = UIImage(cgImage: cgThumbImage) //7
                DispatchQueue.main.async { //8
                    completion(thumbNailImage) //9
                }
            } catch {
                print(error.localizedDescription) //10
                DispatchQueue.main.async {
                    let img:UIImage = #imageLiteral(resourceName: "fullimage")
                    completion(img) //11
                }
            }
        }
    }
}

extension UIView {
    func addDynamicCornerAndShadow(cornerRadii: CGSize, maskedCorners: CACornerMask, shadowColor: UIColor, shadowOpacity: Float, shadowOffset: CGSize, shadowRadius: CGFloat) {
      
        let cornerRadius = min(bounds.width, bounds.height) / 2.0

        var rectCorners: UIRectCorner = []
        if maskedCorners.contains(.layerMinXMinYCorner) {
            rectCorners.insert(.topLeft)
        }
        if maskedCorners.contains(.layerMaxXMinYCorner) {
            rectCorners.insert(.topRight)
        }
        if maskedCorners.contains(.layerMinXMaxYCorner) {
            rectCorners.insert(.bottomLeft)
        }
        if maskedCorners.contains(.layerMaxXMaxYCorner) {
            rectCorners.insert(.bottomRight)
        }
        let maskPath = UIBezierPath(
            roundedRect: bounds,
            byRoundingCorners: rectCorners,
            cornerRadii: cornerRadii
        )

        let maskLayer = CAShapeLayer()
        maskLayer.path = maskPath.cgPath
        layer.mask = maskLayer

        layer.shadowColor = shadowColor.cgColor
        layer.shadowOpacity = shadowOpacity
        layer.shadowOffset = shadowOffset
        layer.shadowRadius = shadowRadius
    }
}

extension URL {

}

extension AVAsset {

    func generateThumbnail(completion: @escaping (UIImage?) -> Void) {
        DispatchQueue.global().async {
            let imageGenerator = AVAssetImageGenerator(asset: self)
            let time = CMTime(seconds: 0.0, preferredTimescale: 600)
            let times = [NSValue(time: time)]
            imageGenerator.generateCGImagesAsynchronously(forTimes: times, completionHandler: { _, image, _, _, _ in
                if let image = image {
                    completion(UIImage(cgImage: image))
                } else {
                    completion(nil)
                }
            })
        }
    }
}

extension UITabBarController {
    /// Extends the size of the `UITabBarController` view frame, pushing the tab bar controller off screen.
    /// - Parameters:
    ///   - hidden: Hide or Show the `UITabBar`
    ///   - animated: Animate the change
    func setTabBarHidden1(_ hidden: Bool, animated: Bool) {
        guard let vc = selectedViewController else { return }
        guard tabBarHidden != hidden else { return }
        
        let frame = self.tabBar.frame
        let height = frame.size.height
        let offsetY = hidden ? height : -height

        UIViewPropertyAnimator(duration: animated ? 0.3 : 0, curve: .easeOut) {
            self.tabBar.frame = self.tabBar.frame.offsetBy(dx: 0, dy: offsetY)
            self.selectedViewController?.view.frame = CGRect(
                x: 0,
                y: 0,
                width: vc.view.frame.width,
                height: vc.view.frame.height + offsetY
            )
            
            self.view.setNeedsDisplay()
            self.view.layoutIfNeeded()
        }
        .startAnimation()
    }
    
    /// Is the tab bar currently off the screen.
    private var tabBarHidden: Bool {
        tabBar.frame.origin.y >= UIScreen.main.bounds.height
    }
}


import UIKit
import Combine

extension UITableView {
    
    func setEmptyView(message: String, imageName: String? = nil, buttonText: String? = nil,buttonBackGroundImg: String? = nil, buttonAction: (() -> Void)? = nil) {
        // Create a label to display the message
        let messageLabel = UILabel()
        messageLabel.text = message
        messageLabel.textColor = .gray
        messageLabel.numberOfLines = 0
        messageLabel.textAlignment = .center
        messageLabel.font = UIFont.systemFont(ofSize: 16)

        // Create a view to hold the message label
        let emptyView = UIView()
        emptyView.addSubview(messageLabel)

        // Center the message label in the empty view
        messageLabel.translatesAutoresizingMaskIntoConstraints = false
        messageLabel.centerXAnchor.constraint(equalTo: emptyView.centerXAnchor).isActive = true
        messageLabel.centerYAnchor.constraint(equalTo: emptyView.centerYAnchor).isActive = true

        // Add an optional background image view
        if let imageName = imageName {
            let imageView = UIImageView(image: UIImage(named: imageName))
            imageView.contentMode = .scaleAspectFit
            emptyView.addSubview(imageView)

            imageView.translatesAutoresizingMaskIntoConstraints = false
            imageView.widthAnchor.constraint(equalToConstant: 250).isActive = true
            imageView.heightAnchor.constraint(equalToConstant: 250).isActive = true
            imageView.centerXAnchor.constraint(equalTo: emptyView.centerXAnchor).isActive = true
            imageView.bottomAnchor.constraint(equalTo: messageLabel.topAnchor, constant: 30).isActive = true
            messageLabel.text = ""
        }

        // Add an optional button
        if let buttonBackGroundImg = buttonBackGroundImg, let buttonAction = buttonAction {
            
            let button = UIButton()
            button.setTitle(buttonText, for: .normal)
            button.setImage(UIImage(named: buttonBackGroundImg ), for: .normal)
            button.addTarget(self, action: #selector(buttonTapped), for: .touchUpInside)
            emptyView.addSubview(button)

            button.translatesAutoresizingMaskIntoConstraints = false
            button.topAnchor.constraint(equalTo: messageLabel.bottomAnchor, constant: 20).isActive = true
            button.centerXAnchor.constraint(equalTo: emptyView.centerXAnchor).isActive = true
            button.tag = 1
            button.tintColor = nil
            objc_setAssociatedObject(button, &AssociatedKeys.buttonActionClosure, buttonAction, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
        }

        // Set the table view's background view to the empty view
        self.backgroundView = emptyView
        self.separatorStyle = .none
    }

    @objc private func buttonTapped(_ sender: UIButton) {
            // Retrieve the button action closure from the button's tag
            if let buttonAction = objc_getAssociatedObject(sender, &AssociatedKeys.buttonActionClosure) as? () -> Void {
                // Call the button action closure
                buttonAction()
            }
        }

    func restore1() {
        DispatchQueue.main.async {
            self.backgroundView = nil
            self.separatorStyle = .none
        }
        // Remove the empty view when data is available
        
    }
    
}

extension UICollectionView {
    
    private struct AssociatedKeys {
        static var refreshAction = "refreshAction"
        static var buttonActionClosure = "buttonActionClosure"
    }
    
    func setEmptyView(message: String, imageName: String? = nil, buttonText: String? = nil,buttonBackGroundImg: String? = nil, buttonAction: (() -> Void)? = nil) {
        // Create a label to display the message
        let messageLabel = UILabel()
        messageLabel.text = message
        messageLabel.textColor = .gray
        messageLabel.numberOfLines = 0
        messageLabel.textAlignment = .center
        messageLabel.font = UIFont.systemFont(ofSize: 16)

        // Create a view to hold the message label
        let emptyView = UIView()
        emptyView.addSubview(messageLabel)

        // Center the message label in the empty view
        messageLabel.translatesAutoresizingMaskIntoConstraints = false
        messageLabel.centerXAnchor.constraint(equalTo: emptyView.centerXAnchor).isActive = true
        messageLabel.centerYAnchor.constraint(equalTo: emptyView.centerYAnchor).isActive = true

        // Add an optional background image view
        if let imageName = imageName {
            let imageView = UIImageView(image: UIImage(named: imageName))
            imageView.contentMode = .scaleAspectFit
            emptyView.addSubview(imageView)

            imageView.translatesAutoresizingMaskIntoConstraints = false
            imageView.widthAnchor.constraint(equalToConstant: 250).isActive = true
            imageView.heightAnchor.constraint(equalToConstant: 250).isActive = true
            imageView.centerXAnchor.constraint(equalTo: emptyView.centerXAnchor).isActive = true
            imageView.bottomAnchor.constraint(equalTo: messageLabel.topAnchor, constant: 30).isActive = true
            messageLabel.text = ""
        }

        // Add an optional button
        if let buttonBackGroundImg = buttonBackGroundImg, let buttonAction = buttonAction {
            
            let button = UIButton()
            button.setTitle(buttonText, for: .normal)
            button.setImage(UIImage(named: buttonBackGroundImg ), for: .normal)
            button.addTarget(self, action: #selector(buttonTapped), for: .touchUpInside)
            emptyView.addSubview(button)

            button.translatesAutoresizingMaskIntoConstraints = false
            button.topAnchor.constraint(equalTo: messageLabel.bottomAnchor, constant: 20).isActive = true
            button.centerXAnchor.constraint(equalTo: emptyView.centerXAnchor).isActive = true
            button.tag = 1
            button.tintColor = nil
            objc_setAssociatedObject(button, &AssociatedKeys.buttonActionClosure, buttonAction, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
        }

        // Set the table view's background view to the empty view
        self.backgroundView = emptyView
        
    }

    @objc private func buttonTapped(_ sender: UIButton) {
            // Retrieve the button action closure from the button's tag
            if let buttonAction = objc_getAssociatedObject(sender, &AssociatedKeys.buttonActionClosure) as? () -> Void {
                // Call the button action closure
                buttonAction()
            }
        }

    func restore() {
        // Remove the empty view when data is available
        self.backgroundView = nil
        
    }
    
    func updateCollecforNoData(count:Int,msg:String? = "No data found",dataLoded:Bool){
        if dataLoded {
            if   count == 0{
                self.setEmptyView(message: msg ?? "")
            }else{
                self.restore()
            }
        }
    }
}

extension UIImageView {
    func makeRounded() {
        self.layer.cornerRadius = self.frame.size.width / 2
        self.clipsToBounds = true
    }
}
extension UINavigationController {
    func navigateToViewController(ofClass targetClass: AnyClass, animated: Bool = true) {
        if let viewController = self.viewControllers.first(where: { $0.isKind(of: targetClass) }) {
            self.popToViewController(viewController, animated: animated)
        } else {
            print("ViewController of class \(targetClass) not found in the navigation stack.")
        }
    }
}
extension UITableView {
    func addPullToRefresh(refreshAction: @escaping () -> Void) {
        let refreshControl = UIRefreshControl()
        refreshControl.addTarget(self, action: #selector(handleRefreshAction(sender:)), for: .valueChanged)
        self.refreshControl = refreshControl
        self.refreshAction = refreshAction
    }

    @objc private func handleRefreshAction(sender: UIRefreshControl) {
        refreshAction?()
    }

    private struct AssociatedKeys {
        static var refreshAction = "refreshAction"
        static var buttonActionClosure = "buttonActionClosure"
    }

    private var refreshAction: (() -> Void)? {
        get {
            return objc_getAssociatedObject(self, &AssociatedKeys.refreshAction) as? () -> Void
        }
        set {
            objc_setAssociatedObject(self, &AssociatedKeys.refreshAction, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
        }
    }
    func endRefreshing() {
           refreshControl?.endRefreshing()
       }
}
enum AppStoryboard : String {
    
    case Main,Home,NewRquest,Service,Setting,Chat
}

extension AppStoryboard {

    var instance : UIStoryboard {
        
        return UIStoryboard(name: self.rawValue, bundle: Bundle.main)
    }
    
    func viewController<T : UIViewController>(_ viewControllerClass : T.Type,
                        function : String = #function, // debugging purposes
                        line : Int = #line,
                        file : String = #file) -> T {
        
        let storyboardID = (viewControllerClass as UIViewController.Type).storyboardID
        
        guard let scene = instance.instantiateViewController(withIdentifier: storyboardID) as? T else {
            
            fatalError("ViewController with identifier \(storyboardID), not found in \(self.rawValue) Storyboard.\nFile : \(file) \nLine Number : \(line) \nFunction : \(function)")
        }
    
        return scene
    }
    
    func initialViewController() -> UIViewController? {
        
        return instance.instantiateInitialViewController()
    }
}

extension UIViewController {
    
    // Not using static as it wont be possible to override to provide custom storyboardID then
    
    static func instantiate(fromAppStoryboard appStoryboard: AppStoryboard) -> Self {
        return appStoryboard.viewController(self)
    }
    class var storyboardID : String {
        
        return "\(self)"
    }
    func updateRecycleCollView(collectionView:UICollectionView,count:Int,msg:String? = "") {
        if count == 0 {
         //   collectionView.toggleNoDataLabel(true, withText: msg)
        } else {
        //    collectionView.toggleNoDataLabel(false)
        }
        DispatchQueue.main.async {
            collectionView.reloadData()
        }
    }
    func updateRecycletblView(collectionView:UITableView,count:Int,msg:String? = "",dataLoad:Bool? = true) {
        if dataLoad ?? false {
            if count == 0 {
              //  collectionView.toggleNoDataLabel(true, withText: msg)
            } else {
             //   collectionView.toggleNoDataLabel(false)
            }
            DispatchQueue.main.async {
                collectionView.reloadData()
            }
        }
    }
}
extension String {
    func convertToMMDDYYYY(desireformate:String) -> String? {
        let dateFormatter = DateFormatter()
        dateFormatter.locale = Locale(identifier: "en_US_POSIX")
        
        // Array of possible date formats to check
        let formats = [
            "yyyy-MM-dd",
            "yyyy/MM/dd",
            "yyyy.MM.dd",
            "yyyy-MM-dd HH:mm:ss",
            "yyyy/MM/dd HH:mm:ss",
            "yyyy.MM.dd HH:mm:ss",
            "MM/dd/yyyy",
            "MM-dd-yyyy",
            "dd/MM/yyyy",
            "dd-MM-yyyy"
        ]
        
        for format in formats {
            dateFormatter.dateFormat = format
            if let date = dateFormatter.date(from: self) {
                dateFormatter.dateFormat = desireformate
                let formattedDate = dateFormatter.string(from: date)
                return formattedDate
            }
        }
        
        return nil
    }
} 



extension UIViewController {
    
    // This method gets called automatically once when the app starts
    static let swizzleViewDidAppear: Void = {
        let originalSelector = #selector(viewDidAppear(_:))
        let swizzledSelector = #selector(swizzled_viewDidAppear(_:))
        
        guard let originalMethod = class_getInstanceMethod(UIViewController.self, originalSelector),
              let swizzledMethod = class_getInstanceMethod(UIViewController.self, swizzledSelector) else {
            return
        }
        
        method_exchangeImplementations(originalMethod, swizzledMethod)
    }()
    
    // This is the swizzled method
    @objc func swizzled_viewDidAppear(_ animated: Bool) {
        // Call the original method (which is now swizzled)
     //   self.swizzled_viewDidAppear(animated)
        
        // Print the class name of the view controller
        print("===============================================")
        print("ViewController appeared: \(type(of: self))")
        print("===============================================")
    }
}
